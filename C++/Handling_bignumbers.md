# Big numbers in C++  

간혹 프로그래밍 언어를 사용하다 보면 다양한 형식의 숫자를 처리해야하는 경우가 발생한다.  
변수를 선언할 때 별다른 형을 지정하지 않는 언어는 문제가 없겠지만  
여기서 다루는 C++ 의 경우 변수를 선언할 때 그 형을 지정한다.  

예를들어 정수형 변수를 선언할 때 `int var` 식의 선언문을 사용하는데,  
이는 변수 `var` 이 정수의 범위를 가지는 수를 담을 수 있음을 의미한다.  
위의 예시처럼 선언한 정수형 변수 `var` 는 전체  
4바이트의 크기를 가질 수 있으며 그 범위는 `-2,147,483,648 ~ 2,147,483,647`  까지 이다.  

물론 일반적인 사용을 가정할 때 위 변수의 범위가 문제가 되는 경우는 드물다.  
범위 자체가 넓을 뿐더러 음수 또는 양수만 필요한 경우 `unsigned` 를 붙여 사용하면 실질적인 범위는 2배가 된다.  
뿐만아니라 정수형 변수가 아닌 실수형 변수를 사용하면 8바이트의 저장공간도 사용가능하다.  
*여기에 `unsigned double var` 식의 선언을 한다면 그 범위는 일반 정수형 변수에 비해 4배나 증가한다*  

하지만 이는 어디까지나 일반적인 사용이 기준일 때 가능한 방법이다.  
만약 입력되는 수 또는 계산을 해야하는 수가 실수형 변수의 범위를 월등히 초과하는 경우는 어떤 방법을 사용해야 할까?  
이 문서는 그 방법에 대해 알아본다.  

### Multiplication  
이 부분은 연속되는 수의 곱셈을 처리하는 방법을 다룬다.  
이는 Codewars 에서 출제된 `largeFactorial` 을 해결할 때 사용한 방법이기도 하다.  

예를들어 어떤 프로그램이 입력된 양수의 팩토리얼을 구해야 한다고 가정하자.  
만약 주어진 수가 10이라면 10! = 1 * 2 * 3 * ... * 8 * 9 * 10 = 3628800  의 결과를 출력하는 것을 목표로 한다.  
언뜻 보기에는 계산된 결과물 3628800 은 7자리이므로 일반적인 정수형 변수나  
만일을 대비한다면 `unsigned` 식의 변수를 사용할 것이다.  
그러나 이는 잘못된 생각이다.  
다음의 경우를 살펴보자.  

- 10! = 3628800  
- 11! = 39916800  
- 12! = 479001600  
- 13! = 6227020800
- 14! = 87178291200  
- 15! = 1.3076744e+12
- 20! = 2.432902e+18  

고작 10에서 20까지의 차이가 있음에도 불구하고 이미 12자릿수를 더 사용하는 것을 확인 할 수 있다.  
만약 입력이 500 이라면 `500! = 1.22013682e+1134`, 즉 1135자릿수를 차지하는 어마어마한 길이의 결과가 계산된다.  
이는 C++ 에서 가장 큰 범위를 가진 변수인 double 으로도 처리가 불가능한 결과이다.  
따라서 이러한 팩토리얼 문제는 일반 숫자변수로는 해결이 불가능하다.  

물론 그렇다고 해서 해결할 방법이 없는것은 아니다.  
하지만 그에 앞서 우리는 곱셈의 과정과 자릿수의 특성을 조금 자세하게 살펴봐야 할 필요가 있다.  
예를들어 `14 * 3` 을 계산한다고 가정하자.  
먼저 14 의 일의 자릿수인 4에 3을 곱한다.  
결과로 나온 12는 일의 자리숫자 2 와 올림수 1이 발생한다.  
따라서 일의 자리 숫자는 2 가 되고 14의 십의자리숫자에 3을 곱한다.  
결과로 나온 3에 올림수 1을 더한다.  
그러므로 `14 * 3` 의 결과는 42 가 된다.  

모든 숫자는 자릿수를 가지고 있는데 위에서 예시로 사용한 42의 경우  
4는 십의자리 수를, 2는 일의자리수를 의미한다.  
이러한 자릿수 조건들때문에 수가 길어질 경우 계산에 어려움이 발생한다.  
C++ 에서 정의한 수를 표현하는 변수는 이런 자릿수 조건을 모두 고려하기 때문이다.  

허나 다르게 생각해 본다면 결국 이러한 숫자들도 각각의 숫자만을 생각한다면 그저 한자리 숫자에 불과할 뿐이다.     
그렇다면 사용자가 직접 숫자를 담을 수 있는, 기존과는 다른 저장방식을 사용한다면 어떨까?  

예를들어 임의의 숫자 `123456789` 가 있다고 하자.  
이 숫자를 일반 정수형 변수에 저장하지 않고 별도의 벡터배열을 선언한다.  

`vector<int> rand = {9, 8, 7, 6, 5, 4, 3, 2, 1}`  

이런식으로 수를 넣는다면 그저 한자리숫자가 연속으로 저장된 배열에 불과하다.  
따라서 우리는 직접 이러한 숫자에 자릿수의 의미를 부여해야 한다.  
숫자를 거꾸로 넣은 이유는 아래에서 설명한다.  

이 상태에서 만약 `123456789 * 9` 의 연산을 수행해야 한다고 가정하자.  
그 연산과정은 다음과 같다.  

1. 선언된 벡터배열의 길이만큼 반복문을 작성한다.  
2. 백터배열의 왼쪽부터 각 원소와 9 를 곱한다.  
3. 만약 곱의 결과가 한자리 숫자를 출력한다면 그 원소를 결과로 수정한다.  
4. 결과가 한자리를 초과한다면, 일의 자리 수는 그대로 수정하고 올림수는 별도의 변수에 저장한다.  
5. 배열의 마지막에 도달할 때까지 위 과정을 반복한다.  
6. 반복이 끝나면 벡터배열의 끝에 올림수를 `push_back()` 한다.  

위 과정을 끝내면 최종 벡터배열에는 연산한 결과가 뒤집혀 저장되어있게 된다.  
*출력 할 때만 반대로 해주면 끝*  

당연하게도 처음 벡터배열에 숫자를 거꾸로 넣은 이유는 연산 후에 발생하는 올림수의 삽입을 쉽게 하기 위함이다.  
`vector` 와 `string` 컨테이너는 모두 `pop_back(), push_back()` 같은 멤버함수를 가지고 있는데,   
이 함수를 이용하면 쉽게 배열의 맨 끝에 값을 삽입, 제거 할 수 있다.  

이처럼 연산의 과정을 직접 이용하면 절차는 복잡하겠지만 어떠한 길이의 수도 연산을 할 수 있다.  
이는 비단 곱셈뿐만 아니라 나머지 뺄셈, 덧셈, 나눗셈, 제곱 등의 방법에도 유용하게 사용 될 수 있다.  